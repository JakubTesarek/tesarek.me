<!DOCTYPE html>
<html lang="en">
<head>
	<title>Power of metaclasses | Jakub Tes√°rek</title>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Introduction to metaclasses in Python">

	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

	<link rel="stylesheet" href="/style/main.css">
	<link rel="stylesheet" href="/style/color-brewer.css">

	<script src="/script/setup.js"></script>
</head>
<body>
	<header>
        <menu class="navigation">
            <li><a href="https://tesarek.me">Home</a></li>
            <li><a href="https://tesarek.me#publications">Publications</a></li>
            <li><a href="https://tesarek.us4.list-manage.com/subscribe/post?u=db9cdab3c81c5706fb0ede08a&id=44f897bb92">Subscribe</a></li>
		</menu>
	</header>
	<main>
		<article class="content">
			<header>
				<h1>Power of metaclasses</h1>
				<p>Introduction to metaclasses in Python. You'll learn what metaclasses are, how to construct them and
					at the end we will go through detailed example from Django ORM.</p>
				<p>This article is a transcript of my presentation for Mobile EMEA Summit - Czech Republic 2019.</p>
			</header>
			<blockquote>
				Metaclasses are deeper magic than 99% of users should ever worry about. If you wonder whether you need
				them, you don't. <cite>Tim Peters</cite>
			</blockquote>

			<h2>Everything is a class</h2>
			<p>First thing you have to understand to unravel the mystery of meta classes is that in Python
				<b>everything</b> is an object. Try it yourself.</p>

				<pre><code class="python">isinstance(True, bool)
# True
# True is instance of class bool</code></pre>

				<pre><code class="python">dir(True)
# ['__abs__', '__add__', '__and__', '__bool__', '__ceil__', ...]
# True has its own methods and attributes</code></pre>

				<pre><code class="python">bool()
# False
# Calling constructor of class bool initilizes boolen with default value</code></pre>

				<pre><code class="python">dir(None)
# ['__bool__', '__class__', '__delattr__', '__dir__', '__doc__', ...]
# Even None is an object</code></pre>

			<p>Every object has a class from which it was created. Think of a class as a cookie cutter and instance as
				a cookie. You can use a cookie cutter to create many cookies, but each cookie has to be created using
				cookie cutter. Likewise, each class can create many instances but each instance (or object) has a class
				from which it was created.</p>

			<p>And because we already know that everything in Python is an object, we can deduce that everything in
				Python has a class.</p>

			<p>To find out what class was used to create an object, we can use function
				<code class="python">type()</code> <i>(it's not a regular function as we will find out)</i>.</p>

			<p>For some objects it's easy to guess their class (type):</p>

				<pre><code class="python">class Klass: pass
type(A())
# &lt;class '__main__.Klass'&gt;
# Type of instance of user-defined class is the class itself</code></pre>

				<pre><code class="python">type(1)
# &lt;class 'int'&gt;
# Type of build in variable type is some build-in class</code></pre>

				<pre><code class="python">type([])
# &lt;class 'list'&gt;
# The same applies for build-in structers</code></pre>

				<pre><code class="python">type(None)
# &lt;class 'NoneType'&gt;
# As we shown before, even None has it's own type</code></pre>

			<p>For other objects it's not so obvious, what's their type:</p>

				<pre><code class="python">def func(): pass
type(func)
# &lt;class 'function'&gt;
# Functions are instances of class function </code></pre>

				<pre><code class="python">type(open)
# &lt;class 'builtin_function_or_method'&gt;
# But build-in functions have their own special class</code></pre>

				<pre><code class="python">type(exit)
# &lt;class '_sitebuiltins.Quitter'&gt;
# Some build in functions are instance of even more special classes
</code></pre>

				<pre><code class="python">import math
type(math)
# &lt;class 'module'&gt;
# And lastly, modules are instances of module class.</code></pre>

			<h2>What are metaclasses?</h2>
			<p>You are probably asking now "So what's a class of a class?". Smart question.</p>
			<p>Classes are objects too (everything is an object, remember?) and as such they have a class. Class of
				class is called <b>metaclass</b>.</p>

			<p><b>Any class whose instances are themselves classes, is a metaclass. Class is an instance of its
				metaclass.</b></p>

			<p>Let's try to look at some metaclasses.</p>

			<pre><code class="python">class Klass: pass
type(Klass)
# &lt;class 'type'&gt;</code></pre>

			<p>If you are not familiar with metaclasses, this probably surprised you. But it's correct, type of classes
				is called <code class="python">type</code>.</p>

			<p>It's probably good time to look at the function <code class="python">type()</code> we kept calling all
				the time. As I suggested earlier, it's not a regular function.</p>

			<pre><code class="python">type(type)
# &lt;class 'type'&gt;</code></pre>

			<p>In fact, <code class="python">type</code> is not a function. It's a class. And not only that it is its
				own type. It is a top level class used to create all other classes. As with most classes, we can call
				its constructor to create new instances. And that's what we've been doing the whole time. Calling
				<code class="python">type(12)</code> simply creates a class from given arguments. When we pass number
				<code class="python">12</code> for example, Python uses the value to figure out what class we want - in
				this case it's <code class="python">&lt;class 'int'&gt;</code> that already existed. But we can also use
				<code class="python">type</code> to create a brand new classes.</p>

			<h2>Creating classes in the runtime</h2>
			<p>Most often we will use <code class="python">type</code> with one argument to find out a type of some
				object. We can also use it to create new classes in the runtime by passing 3 arguments.</p>

			<pre><code class="python">type('Klass', (), {})
# &lt;class '__main__.Klass'&gt;
# type creates new class
Klass()
# &lt;__main__.Klass object at 0x10d1edac8&gt;
# we can use the new class to create new instances</code></pre>

			<p>We will look at the arguments closer but for now, the first argument is the name of our new class, second
				is a tuple of the parent classes and third is a dictionary of all the attributes, methods etc.</p>

			<h2>How does Python construct new classes?</h2>
			<p>Have you ever think about what happens when you write
                <code class="python">class MyClass(ParentClass): ...</code> in Python? We can simplify it to 5 steps:</p>

            <ol>
                <li>Python sees <code class="python">class</code> definition</li>
                <li>Determinates metaclass - either from named argument <code class="python">metaclass</code> or
                    default <code class="python">type</code></li>
                <li>Reads list of base classes - either as positional arguments of default
                    <code class="python">object</code></li>
                <li>Reads attributes and methods</li>
                <li>Internally calls <code class="python">metaclass(name, bases, attributes)</code></li>
            </ol>

			<pre><code class="python">class Troll(User, metaclass=type):
	def taunt(self):
		print('trololo' * 1000)

# is equivalent to this

Troll = type('Troll', (User,), {'taunt': &lt;function 0x108b20510&gt;})</code></pre>

			<p>As you can see, creating new class is similar to creating new instance of metaclass. In reality, instance
				initialization is little bit more complicated then that. In reality, calling
				<code class="python">Class()</code> is a shortcut for calling <code class="python">__new__</code> and
				<code class="python">__init__</code>. The code above is therefore equivalent to this:</p>

			<pre><code class="python">Troll = type.__new__(type, 'Troll', {'taunt': &lt;function 0x108b20510&gt;})
type.__init__(Troll, 'Troll', (Person,), {'taunt': &lt;function 0x108b20510&gt;})</code></pre>

			<h2>Custom metaclasses</h2>
			<p>Now you should have pretty clear idea of what metaclasses are and why are they important. But what can we
				use them for? Custom metaclasses are useful when we want to modify the behavior of our own classes.
				Instead of trying to explain what that means, I'll give you an example of real code.</p>

			<p>Django framework contains ORM. It allows you define your model objects as classes and Django can generate
				database schema from your classes, makes sure all the relations are consistent and allows you to request
				related model objects. It looks something like this:</p>

			<pre><code class="python">from django.db import models

class Person(models.Model):
	name = models.CharField(max_length=50)
	age = models.PositiveIntegerField()
	pronoun = models.CharField(max_length=300)</code></pre>

			<p>When you create new instance of <code class="python">Person</code> it automatically has setters and
				getters for <code class="python">name</code>, <code class="python">age</code> and
				<code class="python">pronoun</code>. It also automatically validates the inputs and adds methods for
				saving the instance to database. Let's see how we can create something similar using metaclasses.</p>

			<p>Django ORM has way too many features. We will limit ourselves to implementing a
				<code class="python">Model</code> class and an <code class="python">IntegerAttribute</code> that will
				validate that given value is an <code class="python">int</code> bellow some maximum value. We will also
				allow the attribute to have some default value.</p>

			<pre><code class="python">Class IntegerAttribute:
	# This class will represent the integer attribute
	pass

class ModelMeta(type):
	# This is our metaclass for creating model classes
	def __new__(meta, name, bases, dct):
		# We can use either __new__ or __init__ method to modify the behaviour. Let's use __new__
		return super().__new__(meta, name, bases, dct)</code></pre>

			<p>We created a metaclass. If we want to use it right now, we can do it like this:</p>

            <pre><code class="python">class Person(metaclass=ModelMeta): pass</code></pre>

			<p>Adding named attribute to each class declaration is too cumbersome, using inheritance is easier. We can
				use the fact that metaclasses are also inherited and simplify the code.</p>

			<pre><code class="python">Class IntegerAttribute: pass

class ModelMeta(type):
	def __new__(meta, name, bases, dct):
		return super().__new__(meta, name, bases, dct)

<i class="add">class Model(metaclass=ModelMeta):
	pass</i></code></pre>

			<p>If we inherit from <code class="python">Model</code>, we will also automatically use its metaclass so we
				can now create <code class="python">Person</code> class simply by sub-typing
				<code class="python">Model</code>.</p>

			<pre><code class="python">class Person(Model): pass</code></pre>

			<p>Now that all the preparation is ready, let's code! First thing we need to do is to remove all defined
				attributes from the model class because later we will replace it with getters and setters.</p>

			<pre><code class="python">class IntegerAttribute: pass

class ModelMeta(type):
	def __new__(meta, name, bases, dct):
<i class="add">		for key in list(dct):
			# iterate all attributes and remove all IntegerAttributes
			attr = dct[key]
			if isinstance(attr, IntegerAttribute):
				del dct[key]
		# We create the class with modified attribute list</i>
		return super().__new__(meta, name, bases, dct)

class Model(metaclass=ModelMeta): pass</code></pre>

			<p>We can test all <code class="python">IntegerAttributes</code> are removed:</p>

			<pre><code class="python">class Person(Model):
	age = IntegerAttribute()
	name = 'Joe'

print(Person.name)
# Joe

print(Person.age)
# AttributeError: type object 'Person' has no attribute 'age'</code></pre>

			<p>We created a metaclass that removes some attributes. In next step we will replace them with a method that
				will set an instance attribute.</p>

			<pre><code class="python">class IntegerAttribute: pass

class ModelMeta(type):
	def __new__(meta, name, bases, dct):
		for key in list(dct):
			attr = dct[key]
			if isinstance(attr, IntegerAttribute):
<i class="add">				def setter(this, value):
					setattr(this, key, value)
				dct[f'set_{key}'] = setter</i>
				del dct[key]
		return super().__new__(meta, name, bases, dct)

class Model(metaclass=ModelMeta): pass</code></pre>

			<p>Now all instance of the class <code class="python">User</code> have a <code class="python">set_age</code>
				method.</p>

			<pre><code class="python">class User(Model):
	age = IntegerAttribute()

user = User()
user.set_age(42)
print(user.age)
# 42</code></pre>

			<p>Similarly, to the setter we create a getter. Also, we will move both the setter and getter to the
				<code class="python">IntegerAttribute</code> class where they belong. They can't be part of the class
				itself; we have to create them in the runtime.</p>

			<pre><code class="python">class IntegerAttribute:
<i class="add">	def get_setter(self, name):
		def setter(this, value):
			setattr(this, name, value)
		return setter

	def get_getter(self, name):
		def getter(this):
			return getattr(this, name)
		return getter</i>

class ModelMeta(type):
	def __new__(meta, name, bases, dct):
		for key in list(dct):
			attr = dct[key]
			if isinstance(attr, IntegerAttribute):
				dct[f'set_{key}'] = attr.get_setter(key)
<i class="add">				dct[f'get_{key}'] = attr.get_getter(key)</i>
				del dct[key]
		return super().__new__(meta, name, bases, dct)

class Model(metaclass=ModelMeta): pass</code></pre>

			<p>We cannot set and retrieve attribute value by special methods.</p>

			<pre><code class="python">class User(Model):
	age = IntegerAttribute()

user = User()
user.set_age(42)
print(user.get_age())
# 42</code></pre>

			<p>In next step, we'll add the input validation. We'll check that the input is an integer and also add the
				possibility set maximum value.</p>

			<pre><code class="python">class IntegerAttribute:
<i class="add">	def __init__(self, maximum=None):
		self.maximum = maximum</i>

	def get_setter(self, name):
		def setter(this, value):
<i class="add">			if not isinstance(value, int):
				raise TypeError(f'{value} is not of type int')
			if self.maximum is not None and value &gt; self.maximum:
				raise ValueError(f'{value} is larger than {self.maximum}')</i>
			setattr(this, name, value)
		return setter

	def get_getter(self, name):
		def getter(this):
			return getattr(this, name)
		return getter

class ModelMeta(type):
	def __new__(meta, name, bases, dct):
		for key in list(dct):
			attr = dct[key]
			if isinstance(attr, IntegerAttribute):
				dct[f'set_{key}'] = attr.get_setter(key)
				dct[f'get_{key}'] = attr.get_getter(key)
				del dct[key]
		return super().__new__(meta, name, bases, dct)

class Model(metaclass=ModelMeta): pass</code></pre>

			<p>And again, we can test the code works as expected.</p>

			<pre><code class="python">class User(Model):
	age = IntegerAttribute(maximum=100)

user = User()
user.set_age('Joe')
# TypeError: Joe is not of type int
user.set_age(105)
# ValueError: 105 is larger than 100</code></pre>

			<p>Last thing I promised you we'll implement together is the possibility to have a default value. It's a
				simple change and you probably already know how to do that.</p>

			<pre><code class="python">class IntegerAttribute:
<i class="add">	def __init__(self, default=None, maximum=None):
		self.default = default</i>
		self.maximum = maximum

	def get_setter(self, name):
		def setter(this, value):
			if not isinstance(value, int):
				raise TypeError(f'{value} is not of type int')
			if self.maximum is not None and value &gt; self.maximum:
				raise ValueError(f'{value} is larger than {self.maximum}')
			setattr(this, name, value)
		return setter

	def get_getter(self, name):
		def getter(this):
<i class="add">			return getattr(this, name, self.default)</i>
		return getter


class ModelMeta(type):
	def __new__(meta, name, bases, dct):
		for key in list(dct):
			attr = dct[key]
			if isinstance(attr, IntegerAttribute):
				dct[f'set_{key}'] = attr.get_setter(key)
				dct[f'get_{key}'] = attr.get_getter(key)
				del dct[key]
		return super().__new__(meta, name, bases, dct)

class Model(metaclass=ModelMeta): pass</code></pre>

			<p>I will not show you how to test this change as you certainly have your own ideas. If not, you can
				download this code with all the unit-tests
				<a href="https://github.com/JakubTesarek/power-of-metaclasses">from my github</a>.</p>

			<h2>Where to go from here</h2>
			<p>Together we explored the possibilities of metaclasses in Python and we implemented simple model class. If
				you find this interesting, you can continue a add some more features. Here are some ideas what to do.</p>

            <ul>
                <li>Add more attributes types like <code class="python">StringAttribute</code>,
                    <code class="python">DateAttribute</code> etc.</li>
                <li>Implement relations so one instance of <code class="python">Model</code> class can be an
                    attribute of another</li>
                <li>Decorate setter and getter with <code class="python">@property</code> and
                    <code class="python">@property.setter</code></li>
            </ul>

			<p>To find out more about metaclasses I recommend reading
				<a href="https://docs.python.org/3/reference/datamodel.html">Python documentation on Data model</a>.</p>
			<aside>
				<p>Did you find an issue with this article? Please
					<a href="https://github.com/JakubTesarek/tesarek.me/issues/new">file a bug report</a> or even better,
					<a href="https://github.com/JakubTesarek/tesarek.me/edit/master/articles/power-of-metaclasses.html">send a pull request</a>.
					Thank you!</p>
			 </aside>
		</article>
	</main>
	<footer>
		<section>
			<a class="icon external" href="mailto:jakub@tesarek.me">&#xf0e0;</a>
			<a class="icon external" href="https://www.instagram.com/tesarekjakub/">&#xf16d;</a>
			<a class="icon external" href="https://github.com/JakubTesarek">&#xf300;</a>
			<a class="icon external" href="https://www.linkedin.com/in/jakubtesarek/">&#xf30c;</a>
			<a class="icon external" href="https://twitter.com/JakubTesarek">&#xf304;</a>
		</section>
	</footer>
</body>
</html>
