<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="x-ua-compatible" content="ie=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="description" content="Closer look at try/finally, how does it truly works">
        <title>Try/Finally experiments | Jakub Tes√°rek</title>
        <link rel="stylesheet" href="../style/main.css" />
        <link rel="stylesheet" href="../style/color-brewer.css">
        <script src="../script/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </head>
    <body>
        <header>
            <menu>
                <ul class="navigation">
                    <li><a href="https://tesarek.me">Home</a></li>
                    <li><a href="https://tesarek.me#publications">Publications</a></li>
                    <li><a href="https://tesarek.me/resume">Resume</a></li>
                </ul>
            </menu>
        </header>
        <main>
            <article class="content">
                <h1>Try/Finally experiments</h1>

                <p>Can you tell what would be the output of the code just by looking at it? Which <code>return</code>
                    statement will win? And why?</p>

                <pre><code class="python">def test():
    try:
        return 'try'
    finally:
        return 'finally'

print(test())</code></pre>


                <p>It might seem counterintuitive but the output is <code>finally</code>. <code>Finnaly</code>
                    statement is executed every time, no matter what happened in <code>try</code> block.</p>

                <p>This lead me to do some more experiments with <code>try/finally</code>. First some really simple example:</p>

                <pre><code class="python">try:
    print('try')
finally:
    print('finally')

# output:
# try
# finally</code></pre>

                <p>This shouldn't be surprising. First the code in <code>try</code> block is executed, than the <code>finally</code>.</p>
                <p>What would happen if instead of priting from <code>try</code> block, we return the value?</p>

                <pre><code class="python">def test():
    try:
        return 'try'
    finally:
        print('finally')

print(test())

# output:
# finally
# try</code></pre>

                <p>The output is reversed! It seems the function return value is put on hold while the <code>finally</code> block is executed.</p>
                <p>It should not suprise us that all the behaviour we saw so far applies even if we introduce exceptions. But let's try anyway.</p>

                <pre><code class="python">def test():
    try:
        raise Exception()
    except:
        return 'except'
    finally:
        return 'finally'

print(test())

# output:
# finally</code></pre>

                <p>At this point we should not be surprised by this. But what would happen if we raise an exception from a <code>finally</code> block?</p>

                <pre><code class="python">def test():
    try:
        pass
    finally:
        raise Exception()

print(test())

# output:
#Traceback (most recent call last):
#  File "test.py", line 7, in <module>
#    print(test())
#  File "test6.py", line 5, in test
#    raise Exception()
#Exception</code></pre>

                <p>An exception is simply propagated out. It that case, it should even rewrite the return value as we seen before.</p>

                <pre><code class="python">def test():
    try:
        return 'try'
    finally:
        raise Exception()

print(test())

# output:
#Traceback (most recent call last):
#  File "test7.py", line 7, in <module>
#    print(test())
#  File "test7.py", line 5, in test
#    raise Exception()
#Exception </code></pre>

                <p>And it does rewrites it and the function raises an exception instead of returning value. To test if not because exceptions
                    take precedense over return value but because of the <code>finally</code> statement, we can try to switch the statements.</p>

                <pre><code class="python">def test():
    try:
        raise Exception()
    finally:
        return 'finally'

print(test())

# output
# finally</code></pre>

                <p>We see that <code>finally</code> can even overwrite exception if we return value from it. Can it also rewrite recursion exception?</p>
                <pre><code class="python">def recursion():
    recursion()

def test():
    try:
        recursion()
    finally:
        return 'finally'

print(test())

# output:
# finally</code></pre>

                <p>Yes, it works as expected. So what would happen if there was another recursion error in the <code>finally</code> block?</p>
                <pre><code class="python">def recursion():
    recursion()

def test():
    try:
        recursion()
    finally:
        return recursion()

# output:
#Traceback (most recent call last):
#  File "test.py", line 6, in test
#    recursion()
#  File "test.py", line 2, in recursion
#    recursion()
#  File "test.py", line 2, in recursion
#    recursion()
#  File "test.py", line 2, in recursion
#    recursion()
#  [Previous line repeated 994 more times]
#RecursionError: maximum recursion depth exceeded
#
#During handling of the above exception, another exception occurred:
#
#Traceback (most recent call last):
#  File "test.py", line 10, in <module>
#    print(test())
#  File "test.py", line 8, in test
#    return recursion()
#  File "test.py", line 2, in recursion
#    recursion()
#  File "test.py", line 2, in recursion
#    recursion()
#  File "test.py", line 2, in recursion
#    recursion()
#  [Previous line repeated 994 more times]
#RecursionError: maximum recursion depth exceeded</code></pre>

            <p>Call of <code>recursion()</code> on line 6 raises an exception. It get's muted by the <code>finally</code>
                block which than generates exception on it's own on line 8. But we only start the recursion twice. Once on line
                6 an once on line 8. What if we execute the recursions also recursively?</p>

            <pre><code class="python">def recursion():
    recursion()

def test():
    try:
        recursion()
    finally:
        test()

# output:
# Fatal Python error: Cannot recover from stack overflow.
#
# Current thread 0x000000011b1195c0 (most recent call first):
#  File "test.py", line 2 in recursion
#  File "test.py", line 2 in recursion
#  File "test.py", line 2 in recursion
# ...
#  File "test.py", line 2 in recursion
#  File "test.py", line 2 in recursion
#  File "test.py", line 2 in recursion
#  ...
# Abort trap: 6</code></pre>

                <p>Stack overflow. We finally broke python.</p>
                <aside>
                    <p>Did you find an issue with this article? Please <a href="https://github.com/JakubTesarek/tesarek.me/issues/new">file a bug report</a>
                        or even better, <a href="https://github.com/JakubTesarek/tesarek.me/edit/master/articles/try-finally-experiments.html">send a pull request</a>.
                        Thank you!</a></p>
                 </aside>
            </article>
        </main>
        <footer>
            <section>
                <a class="icon external" href="mailto:jakub@tesarek.me">&#xf0e0;</a>
                <a class="icon external" href="https://www.instagram.com/tesarekjakub/">&#xf16d;</a>
                <a class="icon external" href="https://github.com/JakubTesarek">&#xf300;</a>
                <a class="icon external" href="https://www.linkedin.com/in/jakubtesarek/">&#xf30c;</a>
            </section>
        </footer>
    </body>
</html>
